#+OPTIONS: author:nil ^:{}
#+HUGO_BASE_DIR: ../../../../../
#+HUGO_SECTION: post/2024/06
#+HUGO_CUSTOM_FRONT_MATTER: :toc true
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DRAFT: true
#+DATE: [2024-06-19 三 10:10]
#+TITLE: 内核考试题
#+HUGO_TAGS:
#+HUGO_CATEGORIES: kernel
#+HUGO_CUSTOM_FRONT_MATTER: :image https://r2.guolongji.xyz/allinaent/2024/06/92a1feeab471b12646b9c76edccc1546.jpg

内核考试的范围广，难度大，想要在没有网络，仅参考内核代码的情况下写出符和题目要求的程序是
极难的。那如何在规则允许的情况下，快速读懂问题，找到关键信息，合理编码解决问题呢？这个问题
很大。但是第一步，是对各个模块的基本概念熟悉，不要因为概念的混乱导致做题成一个糊涂蛋！

* 初级题

** 题目一

一、开发内核模块，模块名：uos-kernel_test2024-01。实现一个简单数据库，支持CRUD（增查改删）。

1.通过/dev/uosdb设备与用户层通信，使用ioctl实现CRUD功能。

数据库每条记录字段定义如下：
#+begin_src c
  struct uosdb_record {
          pid_t pid; // 进程号
          int key; // 键
          char *val; // 值
          unsigned int vlen; // 值的长度，最大为一页
  };
#+end_src


ioctl的cmd定义如下：

- cmd=1：新增一条记录。ioctl传5个参数，第3、4、5参数分别传：key、val、vlen，key必须大于0。若key已存在返回返回-EEXIST;
- cmd=2：查询记录。ioctl传6个参数，第3、4参数分别传：key、buffer、 buffer_len、out_len。当key为0时，查询当前进程所有的记录；
- cmd=3： 修改历史记录。 ioctl的第3、4、5参数分别传：key，new_val，new_vlen，修改key对应的val值，若key不存存，返回-ENOENT;
- cmd=4: 删除历史记录。ioctl传3个参数，第3个参数传key，若key不存存，返回-ENOENT;

2.用户态多进程/多线程操作数据库时，确保数据正常和一致

- 答题结果及提交形式：
- 提交的代码需加入必要的注释；
- 提交简要的设计文档以及使用说明；
- 代码编译以及运行过程的录像；

** 题目二

二、开发一个字符设备驱动，内部最大缓存区为1M，支持O_NONBLOCK标志位，即在进行文件读写时若设置了 O_NONBLOCK 标志
位则使用非堵塞访问，即当设备内部缓存区为空时read系统调用立刻返回对应的错误码，当设备内部缓存区满时write系统调
用直接立刻返回相应的错误码。不然则使用堵塞访问，即当设备内部缓存区为空时read系统调用应等待缓存区有数据时再读
取数据返回，当设备内部缓存区满时write系统调用应等待缓存区有空间时写入数据再返回。

要求：
- 必须开发内核模块实现此功能；
- 字符设备文件名为/dev/my_char_dev；
- O_NONBLOCK标志位可以在系统调用open时设置，也可以在系统调用fcntl时设置；

答题结果及提交形式：
- 提交的代码需加入必要的注释；
- 提交简要的设计文档以及使用说明；
- 代码编译以及运行过程的录像；

* 中级题

** 题目三

三、通过增加系统调用接口，实现如下功能
1.增加系统调用，系统调用定义：sys_uos_kernel_test2024-01(int cmd, char __user *buffer, unsigned int buffer_len);

cmd定义如下：

cmd=1：返回当前进程的vma信息。每个vma占一行，每行包括起始虚拟地址，vma的flag，输出如下：

vma1: range=0x0000-0xffff, flag=0x1234

vma2: range=0x10000-0xfffff, flag=0x2345

...

cmd=2：返回当前进程已注册的信号处理器。每个结果占一行，每行包括信号、处理函数地址，输出如下：

signal1：signo=2, handler=0xabde3333

signal2：signo=3, handler=0xabde3333

....

cmd=3：返回当前进程已打开文件信息。每个已打开文件占一行，每行包括fd号、文件名。

file1: fd=1, name=xxxx,

file2: fd=2, name=xxxx,

...

2.增加2个系统调用，在内核里实现为用户空间程序的分配、释放内存。分配、释放的功能与glibc里提供的malloc、free功能类似。

要求：

a分配的内存必须是连续的物理内存，且最大支持16M。

b返回用户可用的虚拟地址，且在内核日志中打印虚拟地址+物理地址。

系统调用定义：

long sys_uos_kernel_test2024_02_malloc(size_t size)

入参：

size 用户期望分配的内存大小，单位：byte

出参：

分配成功，返回虚拟地址

分配失败，返回标准错误码

long sys_uos_kernel_test2024_02_free(long uvaddr);

入参：

uvaddr 用户要释放的虚拟内存地址

出参：

释放成功，返回0

释放失败，返回标准错误码

答题结果及提交形式：

提交的代码需加入必要的注释；

提交简要的设计文档以及使用说明；

代码编译以及运行过程的录像；

** 第四题

"Use After Free"（UAF）漏洞通常是由于在释放内存后继续使用该内存导致的。以下是一个简单的示例；修改或者替换内存
分配/释放（malloc/free）及其相关函数，实现如下功能
#+begin_src c
#include <stdlib.h>

typedef struct {
    int data;
} Object;

int main() {
    Object* obj = (Object*)malloc(sizeof(Object));
    obj->data = 123;

    free(obj);  // 释放内存

    // 在释放内存后继续使用该内存，这将导致 UAF 漏洞
    int data = obj->data;

    return 0;
}
#+end_src

1.在应用程序启动时，初始化影子内存自身映射到的地址段，以禁止程序的其他部分访问影子内存。

2.程序使用malloc申请内存时，在影子内存中记录每个字节使用情况。

3.free的时候在影子内存中记录状态。

4.使用mprotect来模拟编译器插装，捕获信号，并打印"Use After Free"信息。

答题结果及提交形式：
- 提交的代码需加入必要的注释；
- 提交简要的设计文档以及使用说明；
- 代码编译以及运行过程的录像；

* 高级题

** 第五题

实现一个新的文件系统dtmpfs：

1.启动时预留256M物理内存。

2.修改ramfs，实现dramfs：使用预留的物理内存存放文件数据。（提示：实现一个简单的预留内存分配器；修改read/write路径以使用预留内存；无需实现mmap）

3.实现文件的自动删除。超时时间可以通过挂载参数filetimeout指定，其默认时间可以通过模块参数指定，默认为60s。

4.实现文件名的大小写转换：大小写指向同一文件，可以通过任意大小写文件名索引该文件。文件所有者读取目录内容时，返回大写文件名，其他用户则返回小写文件名。

答题结果及提交形式：
- 提交的代码需加入必要的注释；
- 提交简要的设计文档以及使用说明；
- 代码编译以及运行过程的录像；

* 准备资料

** 一
实现一个新的系统调用sys_7 ，并编写与之配套的应用层程序。

** 二

实现一个杂项设备/dev/uosmisc，并实现它的mmap、ioctl接口。
要求：
mmap时，写入的数据，在下次映射时能读出来。
ioctl实现命令：UOS_IOC_SETINFO:设置一些信息，UOS_IOC_GETINFO：读取设置的信息。

** 三
在procfs里实现一个接口/proc/uos/param1，能对该接口进行读写。

这个问题问题 GPT 可以绐出一个回答。要么把这个回答保存下来，那么知道从内核哪个地方能找到类似的参
考。此题可以源文件加 ko 的方式来编译，直接找个测试的机器就可以做出来，完成后将代码保存一份。
其实可以单独写成博客。

已完成。

** 四
在sysfs里实现一个接口/sys/uos/param1，能对该接口进行读写。

好的问题可以引导人逐渐了解清楚这些模块的运做原理。

已完成。

** 五
在sysctl里实现一个接口/proc/sys/kernel/param1，能对该接口进行读写。

此题与三四题类似。/proc/sys 是 /sys 早期的接口。
sysctl 是一个用于在运行时修改内核参数的工具，它可以通过命令行直接操作内核参数，也可以通过配置文件
进行批量管理。

sysctl 当中还有 net debug dev 之类的。可以用 sysctl -a 来查看。之前写应用的时候
就想过一些接口可以更改内存当中的值，而 linux 内核则直接提供了这种机制，确实是很有用的
东西。

算是完成。

** 六
在XFS里增加一个扩展属性UOS_XATTR，并且在读文件时，在dmesg里输出该属性的值。

题目的含义不是很清楚。在只绐一个文件增加扩展属性还是所有的文件都增加扩展属性呢？

此题有些难度，先不做了。

** 七
用EBPF实现一个过滤器。可以过滤指定IP、端口的数据包。

** 八
在内核里实现，按下“CTRL+ALT”时，在dmesg里增加一个打印。

** 九
实现一个日志模块，用于给文件里记录日志。包含一个导出接口：

uos_printk(const char *path, const char *fmt, ...);

path：日志文件路径

fmt：输出格式

...：输出参数列表

每个日志输出时，需要在前面添加：timestamp, uid、pid信息。
例如：
uos_printk("/home/uos.log", “count=%d.\n", 16);
输出：2024-05-20 15:01 uid=12, pid=1000, count=16.

** 十
用户user01创建的文件，如果文件名里有a，则将a转成A。
如：
$ touch abc
$ ls
Abc

** 十一
内存：撰写内核代码，将当前系统占用内存最多的进程的内存，主动的swap换出

来思考一下。解决这些题需要用到哪些 API ？为啥感觉这些题非常难。


